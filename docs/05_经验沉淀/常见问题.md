# MemeHunter 常见问题与经验沉淀

> 开发过程中遇到的问题及解决方案

---

## 一、前端开发问题

### 1.1 RainbowKit 与 Vite 7 / React 19 兼容性问题

**问题**：使用 `@rainbow-me/rainbowkit` 时，Vite 7 构建报错 `"baseAccount" is not exported`

**原因**：RainbowKit 2.x 与新版 Vite/React 存在兼容性问题

**解决方案**：
- 移除 RainbowKit，改用原生 wagmi hooks (`useConnect`, `useDisconnect`)
- 直接使用 `injected()` 连接器

```typescript
// 正确做法
import { useConnect, useDisconnect } from 'wagmi';
const { connect, connectors } = useConnect();
const injectedConnector = connectors.find((c) => c.id === 'injected');
connect({ connector: injectedConnector });
```

---

### 1.2 Tailwind CSS v4 配置变化

**问题**：Tailwind v4 使用 `@tailwind` 指令报错

**原因**：Tailwind v4 更新了 PostCSS 插件配置方式

**解决方案**：
1. 安装 `@tailwindcss/postcss`
2. 更新 `postcss.config.js`：
```javascript
export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
```
3. 更新 `index.css`：
```css
@import "tailwindcss";
```

---

### 1.3 PowerShell 不支持 `&&` 操作符

**问题**：在 Windows PowerShell 中使用 `npm install && npx xxx` 报错

**原因**：PowerShell 使用 `;` 分隔命令，不支持 `&&`

**解决方案**：分开执行命令或使用 `;`
```powershell
# 错误
npm install && npm run build

# 正确
npm install; npm run build
```

---

## 二、合约交互问题

### 2.1 Session Key 签名格式

**问题**：前端签名与合约验证不匹配

**原因**：需要使用与合约一致的消息哈希格式

**解决方案**：
```typescript
// 与合约 _getMessageHash 保持一致
const messageHash = keccak256(
  encodePacked(
    ['string', 'bytes32'],
    [
      '\x19Ethereum Signed Message:\n32',
      keccak256(
        encodePacked(
          ['uint8', 'uint8', 'uint256'],
          [memeId, netSize, BigInt(nonce)]
        )
      ),
    ]
  )
);
```

---

### 2.2 Hunt API 401 签名验证失败

**问题**：前端调用 `/api/hunt` 返回 `401 Unauthorized` 或合约返回 `Invalid signature`

**原因**：签名/验证流程存在两个问题

1. **编码方式不一致**：
   - 合约 `MemeHunter.sol`：使用 `abi.encode` (填充到 32 字节)
   - 前端/后端：错误使用了 `encodePacked` (紧凑编码，不填充)
   - 两种编码产生不同的哈希值

2. **双重 EIP-191 前缀**：
   - 前端手动添加了 `\x19Ethereum Signed Message:\n32` 前缀
   - 然后 `signMessage` 函数又自动添加了一次前缀
   - 导致签名的是双重前缀消息

**解决方案**：

```typescript
// relayer.ts - 正确做法：使用 encodeAbiParameters (匹配合约的 abi.encode)
import { keccak256, encodeAbiParameters } from 'viem';

const innerHash = keccak256(
  encodeAbiParameters(
    [{ type: 'uint8' }, { type: 'uint8' }, { type: 'uint256' }],
    [memeId, netSize, BigInt(nonce)]
  )
);

// signMessage 会自动添加 EIP-191 前缀
const signature = await signMessage({
  message: { raw: innerHash },
  privateKey: sessionPrivateKey,
});
```

**教训**：
- `abi.encode` 对应 viem 的 `encodeAbiParameters`
- `abi.encodePacked` 对应 viem 的 `encodePacked`
- 两者编码结果完全不同，必须与合约保持一致

**教训**：
- `signMessage` / `verifyMessage` 会自动处理 EIP-191 前缀
- 手动添加前缀会导致双重前缀，签名永远无法验证通过

---

### 2.3 Session Key 授权卡在 "Authorizing..." 状态

**问题**：点击授权 Session Key 后，按钮一直显示 "Authorizing..." 转圈，无法完成

**原因**：`useWriteContract` 的错误没有被处理
- `writeContract()` 失败时（用户拒绝签名或交易失败）
- `isAuthorizing` 状态没有被重置
- UI 永远卡在加载状态

**解决方案**：添加错误处理 useEffect

```typescript
// useSessionKey.ts
const { writeContract, error: writeError, reset: resetWrite } = useWriteContract();
const { isError: txError } = useWaitForTransactionReceipt({ hash: txHash });

// 处理写入错误
useEffect(() => {
  if (writeError) {
    setError(writeError.message);
    setIsAuthorizing(false);
    resetWrite();
  }
}, [writeError, resetWrite]);

// 处理交易错误
useEffect(() => {
  if (txError) {
    setError('Transaction failed on chain');
    setIsAuthorizing(false);
    resetWrite();
  }
}, [txError, resetWrite]);
```

**教训**：使用 wagmi hooks 时，必须同时处理成功和失败两种情况，否则会导致 UI 状态不一致。

---

## 变更记录

| 日期 | 变更内容 |
|------|----------|
| 2026-01-17 | 初始创建，记录前端开发踩坑 |
| 2026-01-17 | 添加 nonce API 降级处理、WebSocket 连接问题 |
| 2026-01-17 | 添加 Hunt API 401 签名验证失败问题（前后端编码方式不一致） |
| 2026-01-17 | 添加 Session Key 授权卡死问题（wagmi hooks 错误处理） |
