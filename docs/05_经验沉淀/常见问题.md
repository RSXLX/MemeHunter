# MemeHunter 常见问题与经验沉淀

> 开发过程中遇到的问题及解决方案

---

## 一、前端开发问题

### 1.1 RainbowKit 与 Vite 7 / React 19 兼容性问题

**问题**：使用 `@rainbow-me/rainbowkit` 时，Vite 7 构建报错 `"baseAccount" is not exported`

**原因**：RainbowKit 2.x 与新版 Vite/React 存在兼容性问题

**解决方案**：
- 移除 RainbowKit，改用原生 wagmi hooks (`useConnect`, `useDisconnect`)
- 直接使用 `injected()` 连接器

```typescript
// 正确做法
import { useConnect, useDisconnect } from 'wagmi';
const { connect, connectors } = useConnect();
const injectedConnector = connectors.find((c) => c.id === 'injected');
connect({ connector: injectedConnector });
```

---

### 1.2 Tailwind CSS v4 配置变化

**问题**：Tailwind v4 使用 `@tailwind` 指令报错

**原因**：Tailwind v4 更新了 PostCSS 插件配置方式

**解决方案**：
1. 安装 `@tailwindcss/postcss`
2. 更新 `postcss.config.js`：
```javascript
export default {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
```
3. 更新 `index.css`：
```css
@import "tailwindcss";
```

---

### 1.3 PowerShell 不支持 `&&` 操作符

**问题**：在 Windows PowerShell 中使用 `npm install && npx xxx` 报错

**原因**：PowerShell 使用 `;` 分隔命令，不支持 `&&`

**解决方案**：分开执行命令或使用 `;`
```powershell
# 错误
npm install && npm run build

# 正确
npm install; npm run build
```

---

## 二、合约交互问题

### 2.1 Session Key 签名格式

**问题**：前端签名与合约验证不匹配

**原因**：需要使用与合约一致的消息哈希格式

**解决方案**：
```typescript
// 与合约 _getMessageHash 保持一致
const messageHash = keccak256(
  encodePacked(
    ['string', 'bytes32'],
    [
      '\x19Ethereum Signed Message:\n32',
      keccak256(
        encodePacked(
          ['uint8', 'uint8', 'uint256'],
          [memeId, netSize, BigInt(nonce)]
        )
      ),
    ]
  )
);
```

---

### 2.2 Hunt API 401 签名验证失败

**问题**：前端调用 `/api/hunt` 返回 `401 Unauthorized` 或合约返回 `Invalid signature`

**原因**：签名/验证流程存在两个问题

1. **编码方式不一致**：
   - 合约 `MemeHunter.sol`：使用 `abi.encode` (填充到 32 字节)
   - 前端/后端：错误使用了 `encodePacked` (紧凑编码，不填充)
   - 两种编码产生不同的哈希值

2. **双重 EIP-191 前缀**：
   - 前端手动添加了 `\x19Ethereum Signed Message:\n32` 前缀
   - 然后 `signMessage` 函数又自动添加了一次前缀
   - 导致签名的是双重前缀消息

**解决方案**：

```typescript
// relayer.ts - 正确做法：使用 encodeAbiParameters (匹配合约的 abi.encode)
import { keccak256, encodeAbiParameters } from 'viem';

const innerHash = keccak256(
  encodeAbiParameters(
    [{ type: 'uint8' }, { type: 'uint8' }, { type: 'uint256' }],
    [memeId, netSize, BigInt(nonce)]
  )
);

// signMessage 会自动添加 EIP-191 前缀
const signature = await signMessage({
  message: { raw: innerHash },
  privateKey: sessionPrivateKey,
});
```

**教训**：
- `abi.encode` 对应 viem 的 `encodeAbiParameters`
- `abi.encodePacked` 对应 viem 的 `encodePacked`
- 两者编码结果完全不同，必须与合约保持一致

**教训**：
- `signMessage` / `verifyMessage` 会自动处理 EIP-191 前缀
- 手动添加前缀会导致双重前缀，签名永远无法验证通过

---

### 2.3 Session Key 授权卡在 "Authorizing..." 状态

**问题**：点击授权 Session Key 后，按钮一直显示 "Authorizing..." 转圈，无法完成

**原因**：`useWriteContract` 的错误没有被处理
- `writeContract()` 失败时（用户拒绝签名或交易失败）
- `isAuthorizing` 状态没有被重置
- UI 永远卡在加载状态

**解决方案**：添加错误处理 useEffect

```typescript
// useSessionKey.ts
const { writeContract, error: writeError, reset: resetWrite } = useWriteContract();
const { isError: txError } = useWaitForTransactionReceipt({ hash: txHash });

// 处理写入错误
useEffect(() => {
  if (writeError) {
    setError(writeError.message);
    setIsAuthorizing(false);
    resetWrite();
  }
}, [writeError, resetWrite]);

// 处理交易错误
useEffect(() => {
  if (txError) {
    setError('Transaction failed on chain');
    setIsAuthorizing(false);
    resetWrite();
  }
}, [txError, resetWrite]);
```

**教训**：使用 wagmi hooks 时，必须同时处理成功和失败两种情况，否则会导致 UI 状态不一致。

---

## 变更记录

| 日期 | 变更内容 |
|------|----------|
| 2026-01-17 | 初始创建，记录前端开发踩坑 |
| 2026-01-17 | 添加 Session Key 授权卡死问题（wagmi hooks 错误处理） |
| 2026-01-17 | 添加 React keys 重复问题（玩家列表去重） |
| 2026-01-17 | 添加 API 500 错误（Nonce 获取失败降级为 0 导致） |
| 2026-01-17 | 添加 Intrinsic Gas Limit 错误（估算不足，需增加 Buffer） |
| 2026-01-17 | 添加 Relayer 余额不足问题（增加启动检查日志） |

---

### 2.4 React List Duplicate Key 错误

**问题**：控制台报错 `Encountered two children with the same key`

**原因**：WebSocket 事件（`playerJoin` 和 `gameState`）可能在短时间内多次触发，导致 `players` 数组中出现重复的玩家 ID。

**解决方案**：在 `useGameSocket` 中更新 `players` 状态时进行去重。
```typescript
setPlayers(prev => {
  const newPlayers = [...prev, player];
  // 基于 id 去重
  return Array.from(new Map(newPlayers.map(p => [p.id, p])).values());
});
```

---

### 2.5 API/Hunt 500 Error (Nonce Mismatch)

**问题**：狩猎请求返回 500，服务端报错 `execution reverted`。

**原因**：
前端 `getNonce` 失败时（网络波动或 API 错误），默认降级返回 `0`。如果用户实际 nonce > 0，使用 nonce=0 签名的交易会在合约中验证失败（Revert）。

**解决方案**：
- **前端**：移除 `getNonce` 的默认 `0` 返回，失败时抛出错误并重试。
- **服务端**：`nonce` API 失败时返回 500 而不是 `0`，让前端明确感知错误。
- **用户端**：提供 "Reset Session" 按钮，清除本地可能不同步的 Session Key。

---

### 2.6 Intrinsic Gas Too Low

**问题**：Relayer 广播交易时报错 `intrinsic gas greater than limit`。

**原因**：`viem` 的 `simulateContract` 估算的 Gas 过于精确（或偏低），在网络拥堵或节点差异时无法通过基础 Gas 检查。

**解决方案**：
在 `txBroadcaster.js` 中手动增加 Gas Buffer：
```javascript
// 增加 200% Buffer 并设置底限
if (request.gas) {
  const bufferGas = request.gas * 200n / 100n;
  request.gas = bufferGas < 500000n ? 500000n : bufferGas;
} else {
  request.gas = 1000000n;
}
```

---

### 2.7 Signer Insufficient Balance

**问题**：交易失败，报错 `Signer had insufficient balance`。

**原因**：Relayer 钱包（负责广播交易并支付 Gas）余额不足。注意：虽然用户支付了狩猎费用，但 Gas 费需要 Relayer 先垫付。

**解决方案**：
- 在 Relayer 启动时检查余额。
- 如果余额低于阈值（如 0.1 MON），在日志中打印醒目的黄色警告。
- 提示开发者及时充值。
